//================================================================================
//
//    平面クラス
//    Author : Araki Kai                                作成日 : 2017/11/28
//
//================================================================================

#ifndef	_PLANE_H_
#define _PLANE_H_



//======================================================================
//
// インクルード文
//
//======================================================================

#include "../CollisionShapeBase.h"

#include <Vector3D.h>



//======================================================================
//
// クラス定義
//
//======================================================================

class Plane : public CollisionShapeBase
{
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
public :
	// 法線と1点コンストラクタ( デフォルト )
	Plane(Vec3 normal_vector = Vec3(0.0f, 0.0f, 0.0f), Vec3 point = Vec3(0.0f, 0.0f, 0.0f));

	// 3点引数コンストラクタ
	Plane(Vec3 point0, Vec3 point1, Vec3 point2);


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
public :
	// デストラクタ
	virtual ~Plane();


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
public :
	// メンバ関数	
	float Length_Point     (Vec3 point) const;
	bool  IsFrontSide_Point(Vec3 point) const;


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
public :
	// メンバ変数
	Vector3D normal_vector_;
	float    adjustmet_d_;
};





//======================================================================
//
// 非静的メンバ関数定義( inline )
//
//======================================================================

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// [ 法線と1点コンストラクタ( デフォルト ) ]
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

inline Plane::Plane(Vec3 normal_vector, Vec3 point)
	: CollisionShapeBase(CollisionShapeBase::Type::PLANE),
	  normal_vector_(normal_vector)
{
	normal_vector_.CreateNormalize();

	adjustmet_d_ = -((normal_vector_.x * point.x) + (normal_vector_.y * point.y) + (normal_vector_.z * point.z));
}



//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// [ 3点引数コンストラクタ ]
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

inline Plane::Plane(Vec3 point0, Vec3 point1, Vec3 point2)
	: CollisionShapeBase(CollisionShapeBase::Type::PLANE)
{
	Vec3 temp_normal_vector = Point3_Cross(point0, point1, point2);

	*this = Plane(temp_normal_vector, point0);
}



//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// [ デストラクタ ]
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

inline Plane::~Plane() 
{
}



//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// [ 平面と座標との長さ関数 ]
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

inline float Plane::Length_Point(Vec3 point)  const
{
	return (normal_vector_.x * point.x) + (normal_vector_.y * point.y) + (normal_vector_.z * point.z) + adjustmet_d_;
}



//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// [ 座標が平面の表側にあるか判定関数 ]
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

inline bool Plane::IsFrontSide_Point(Vec3 point)  const
{
	if (Length_Point(point) < 0.0f) return false;

	return true;
}



#endif